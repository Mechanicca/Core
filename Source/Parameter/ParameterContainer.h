/*
 * Parameter_Container.h
 *
 *  Created on: 29.11.2015
 *      Author: martin
 */

#ifndef SOURCE_CORE_PARAMETER_PARAMETER_CONTAINER_H_
#define SOURCE_CORE_PARAMETER_PARAMETER_CONTAINER_H_

/* Standard library inclusions */
#include <map>
#include <sstream>
#include <type_traits>
#include <memory>
#include <mutex>

/* Project specific inclusions */
#include "Parameter/IParameterTagCollection.h"
#include "Parameter/Parameter.h"
#include "Parameter/Exception.h"
#include "Equation/Equation.h"
#include "Data/DesignRulesDBConnector.h"
#if false
#include "Data/Data_DataSelection_GenericDesignRule.h"
#endif

/* Shared library support */
#include "Core_Export.h"

/* As Core_Export.h header is generated during build, the required CORE_EXPORT
 * definition might not exist due to missing header file. In order to prevent
 * syntax errors cause by undefined CORE_EXPORT, define temporary blank one */
#ifndef CORE_EXPORT
	#define CORE_EXPORT
	#define CORE_NO_EXPORT
#endif

#define DEBUG_CONSOLE_OUTPUT	false

namespace Core
{
	/**
	 * @brief Parameter container
	 *
	 * Internally parameter container is std::map which can hold any type of data.
	 *
	 * ParameterContainer is configurable which KEY type to use - using template
	 * parameter PARAMETER_TAG_COLLECTION
	 */
	class CORE_EXPORT ParameterContainer
		:	/* In order to get the shared_ptr for 'this', this feature must be derived. It is required by get method
		       to execute the equations on this parameter container */
			public std::enable_shared_from_this<ParameterContainer>
	{
	public:
		/* Use TIdentifier from parameter tag collection as map key */
		using TParameterContainerKey = IParameterTagCollection::IParameterTag::TIdentifier;

	private:
		/* Define the type of parameter collection */
		using TParameterCollection = std::map<TParameterContainerKey, std::shared_ptr<IParameter>>;

	public:

		/**
		 * @brief Parameter container factory method
		 *
		 * ParameterContainer must be ALLWAYS constructed using std::shared_ptr to avoid std::bad_weak_ptr exception.
		 *
		 * Reason: Base class enable_shared_from_this<Node> has to store a weak_ptr<Node> to itself. This weak_ptr is default-constructed to be null.
		 * When a shared_ptr is constructed to take over ownership of an object, either vÃ­a make_shared or by passing a raw pointer,
		 * it sets said weak_ptr to refer to that new shared_ptr. If you then call shared_from_this() on the object, the weak_ptr
		 * gets locked and another shared_ptr can be returned.
		 *
		 * The only ability to create an instance of ParameterContainer is using this 'Create' method. This ensures ParameterContainer instance to be
		 * constructed only by smart pointers (shared_ptr or unique_ptr --> std::shared_ptr can be constructed from a std::unique_ptr.
		 *
		 * Source: http://stackoverflow.com/a/17135547/5677080
		 */
		template<typename ...ARGUMENTS>
		static std::unique_ptr<ParameterContainer> construct( ARGUMENTS&& ...Arguments ) noexcept
		{
			/* TODO: Rewrite this using std::make_unique */
			return( std::unique_ptr<ParameterContainer>( new ParameterContainer( std::forward<ARGUMENTS>(Arguments)... ) ) );
		}

		/**
		 * @brief Default ParameterContainer destructor
		 *
		 * Generated by compiler
		 */
		~ParameterContainer( void ) = default;

		/**
		 * @brief Bidirectional iterator to parameters stored in container
		 */
		using iterator = typename TParameterCollection::iterator;
		iterator begin( void ) noexcept
		{
			iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the begin iterator */
				tIterator = this->mParameterCollection.begin();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		iterator end( void ) noexcept
		{
			iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the end iterator */
				tIterator = this->mParameterCollection.end();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		/**
		 * @brief Bidirectional iterator to constant parameters stored in container
		 */
		using const_iterator = typename TParameterCollection::const_iterator;
		const_iterator cbegin( void ) noexcept
		{
			const_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the begin const_iterator */
				tIterator = this->mParameterCollection.cbegin();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		const_iterator cend( void ) noexcept
		{
			const_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the end const_iterator */
				tIterator = this->mParameterCollection.cend();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		/**
		 * @brief Reverse bidirectional iterator to parameters stored in container
		 */
		using reverse_iterator = typename TParameterCollection::reverse_iterator;
		reverse_iterator rbegin( void ) noexcept
		{
			reverse_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the begin reverse_iterator */
				tIterator = this->mParameterCollection.rbegin();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		reverse_iterator rend( void ) noexcept
		{
			reverse_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the end reverse_iterator */
				tIterator = this->mParameterCollection.rend();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		/**
		 * @brief Reverse bidirectional iterator to constant parameters stored in container
		 */
		using const_reverse_iterator = typename TParameterCollection::const_reverse_iterator;
		const_reverse_iterator crbegin( void ) noexcept
		{
			const_reverse_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the begin const_reverse_iterator */
				tIterator = this->mParameterCollection.crbegin();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		const_reverse_iterator crend( void ) noexcept
		{
			const_reverse_iterator tIterator;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the end const_reverse_iterator */
				tIterator = this->mParameterCollection.crend();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tIterator );
		}

		/**
		 * @brief Test whether container is empty
		 */
		bool empty( void ) const noexcept
		{
			return( mParameterCollection.empty() );

			bool isEmpty = false;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the emptiness of parameter collection */
				isEmpty = this->mParameterCollection.empty();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( isEmpty );
		}

		/**
		 * @brief Parameter container emptiness check
		 */
		std::size_t size( void ) const noexcept
		{
			std::size_t tSize;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the size of parameter collection */
				tSize = this->mParameterCollection.size();

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			return( tSize );
		}

		/* @brief TODO
		 * TODO
		 * @throws <Core::Exception::EquationNotDefined>	Exception is thrown once the equations domain is defined but the equation is not available
		 * @throws <Core::Exception::ParameterNotFound>		Exception is thrown once the parameter is not found in this container nor in linked one
		 */
			/* TODO: EQUATIONS might be used for several purposes. One of those, primary one, is used to instantiate the specialization of
			 * equation. If it is equal to 'void', no calculations shall be executed (parameters shall be given only). Third purpose might be
			 * to indicate the requested parameter is a specification parameter. Once specification parameter is not found, a special exception shall
			 * be thrown. */
			/* TODO: Rename EQUATIONS to something more fitting the real purpose of this template argument */
		template<typename PARAMETER_TAG, typename EQUATIONS = void>
		std::shared_ptr<typename PARAMETER_TAG::TParameter> get( void ) noexcept( false )
		{
			/* Check whether PARAMETER_TAG is compatible with IParameterTag interface */
			static_assert( std::is_base_of<IParameterTagCollection::IParameterTag, PARAMETER_TAG>::value, "Parameter TAG must be derived from IParameterTag." );

			/* STEP 1 */
			/* First of all, try to calculate the parameter if it is not available but equation shall be defined (if not, an exception is thrown. */
#if false
			try
			{
#endif
				/* If the requested parameter is NOT available anywhere (in this container nor in lined one (works recursively up to the root container in the hierarchy),
				 * calculate and store it first once the equations are defined (EQUATIONS is not VOID) */

				/* If requested parameter is NOT available but threre should be an equation defined to calculate it... */
				if( ( this->isAvailable<PARAMETER_TAG>() == false ) && ( std::is_same<EQUATIONS, void>::value == false ) )
				{
					/* Calculate missing parameter quantity and create the parameter in parameter container */

					/* Run equation and create newly created parameter with calculated quantity into the container */
					/* @throws <Core::Exception::EquationNotDefined> */
					this->create<PARAMETER_TAG>( Design::Equation<EQUATIONS, PARAMETER_TAG, void>()( shared_from_this() ) );
				}
#if false
			}
			/* Exception thrown by equation execution */
			catch( const Core::Exception::EquationNotDefined & Exception )
			{
				/* Rethrow the exception */
				/* TODO: Maybe to add some more information to exception */
				BOOST_THROW_EXCEPTION( Core::Exception::EquationNotDefined() << Core::Exception::Message( Exception.what() ) );

			}
#endif

			/* Construct temporary parameter of typed defined in PARAMETER_TAG */
			std::shared_ptr<typename PARAMETER_TAG::TParameter> tParameter;

			/* STEP 2 */
			/* Try to get the parameter out of this container. It might be calculated in STEP 1 */
			try
			{
				/* Thread-safe parameter collection access block */

				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely get the parameter out of the parameter collection */
				/* @throws <Core::Exception::EquationNotDefined> */
				tParameter = std::dynamic_pointer_cast<typename PARAMETER_TAG::TParameter>( this->mParameterCollection.at( PARAMETER_TAG::ID::value ) );

				/* The lock guard expires here so the parameter collection gets unlocked */
			}
			/* Catching 'out of range' exception means the parameter is not available in current container */
			catch( const std::out_of_range & )
			{
				/* STEP 3 */
				/* Try to get the parameter from linked parameter container */

				/* If there is a valid link to other container... */
				if( !this->mLinkedContainer.expired() )
				{
					/* Once the parameter is requested from linked parameter container, it is under the responsibility of this linked container
					 * to calculate the parameter. Therefore from this point here, the parameter cannot be calculated (=Equation domain is set to 'void'). */
					/* @throws <Exception::ParameterNotFound> */
					tParameter = ( this->mLinkedContainer.lock() )->get<PARAMETER_TAG, void>();
				}
				else
				{
					/* Parameter was not found within this parameter container and there is no linked one. So there is no container which holds requested parameter */
					/* Required parameter was not found in the map */
					std::stringstream Stream;

					/* Write the message into the string stream */
					Stream << "Required parameter cannot be found: " << getParameterInfo<PARAMETER_TAG>();

					BOOST_THROW_EXCEPTION( typename Exception::ParameterNotFound() << Core::Exception::Message( Stream.str() ) );
				}
			}

			/* Try to get Parameter of desired type out of storage container */
			return( tParameter );
		}

		/**
		 * @brief Adds parameter to parameter storage.
		 *
		 * If parameter identified by Key is already existing in std::map, the value of it is overwritten using the Param
		 * value. If parameter identified is NOT existing, Param is added into std::map.
		 * Source: www.stackoverflow.com/questions/17172080/insert-vs-emplace-vs-operator-in-c-map
		 */
		template<typename PARAMETER_TAG>
		std::pair<iterator, bool> add( std::shared_ptr<typename PARAMETER_TAG::TParameter> Parameter ) noexcept
		{
			/* Check whether PARAMETER_TAG is compatible with IParameterTag interface */
			static_assert( std::is_base_of<IParameterTagCollection::IParameterTag, PARAMETER_TAG>::value, "Parameter TAG must be derived from IParameterTag." );

			std::pair<iterator, bool> tRetval;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely insert the parameter into the parameter collection */
				tRetval = this->mParameterCollection.insert( std::pair<TParameterContainerKey, std::shared_ptr<typename PARAMETER_TAG::TParameter>>( PARAMETER_TAG::ID::value, std::move( Parameter ) ) );

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			/* Return insertion result data - iterator and boolean value of operation status */
			return( tRetval );
		}

#if false
		/**
		 * @brief Adds parameters to parameter storage using the design rule.
		 *
		 * The method uses a design rule given by the template parameter to read the parameters defined by the rule.
		 *
		 * @tparam DESIGN_RULE	Design rule to be used for getting the parameters. Must be derived from GenericDesignRule using the same
		 * 						ParameterContainer type. This precondition is set at compile-time by static assertion.
		 *
		 * @param[in] RequestedID	Identification of requested DesignRule option to be read.
		 */
		template<typename DESIGN_RULE>
		void add( const typename DESIGN_RULE::DesignRuleOptionIdentificationEnumType DesignRuleOption )
		{
			/* Check the compatibility of DESIGN_RULE and it's datatype with self ParameterContainer type (aka IDENTIFICATION) */
			static_assert( std::is_base_of<GenericDesignRule<Core::ParameterContainer<PARAMETER_TAG_COLLECTION>, typename DESIGN_RULE::DesignRuleOptionIdentificationEnumType>, DESIGN_RULE >::value, "DesignRule must be derived from GenericDesignRule." );

			/* Design rule instance used to get the data from DesignRules DB */
			std::shared_ptr<DESIGN_RULE> tDesignRule = std::make_shared<DESIGN_RULE>();

			/* Temporary parameter container to store the parameter(s) read by the Design Rule */
			typename DESIGN_RULE::ParameterContainerType tContainer;

			/* Read the parameters */
			tContainer = tDesignRule->getData( static_cast<typename std::underlying_type<typename DESIGN_RULE::DesignRuleOptionIdentificationEnumType>::type>( DesignRuleOption ) );

			/* Merge temporary container with 'this' to add the parameters there */
			(this)->merge( tContainer );
		}
#endif

		void link( const std::shared_ptr<ParameterContainer> Container ) noexcept
		{
			this->mLinkedContainer = Container;
		}

		/**
		 * @brief Adds parameters from another parameter container of the same type
		 *
		 * Parameters in mParameterCollection with the same identification are NOT overwritten by the duplicities coming from 'Container'
		 *
		 */
		void merge( const std::shared_ptr<ParameterContainer> Container ) noexcept
		{
			/* Thread-safe parameter collection access block */
			/* Lock parameter collection */
			std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

			/* Safely insert the parameter into the parameter collection */
			this->mParameterCollection.insert( Container->begin(), Container->end() );

			/* The lock guard expires here so the parameter collection gets unlocked */
		}

		/**
		 * @brief Creates new parameter in container
		 *
		 * Creates new constrained parameter in the container. It takes the Identification given as argument and loads the corresponding
		 * constrained parameter from DesignRules database identified by 'Identification'.
		 *
		 * @param[in] Identification	Constrained parameter identification generated from DesingRules DB in component scope
		 */
		template<typename PARAMETER_TAG>
		void create( typename PARAMETER_TAG::TParameter::TQuantity const & Quantity ) noexcept( false )
		{
			/* Check whether PARAMETER_TAG is compatible with IParameterTag interface */
			static_assert( std::is_base_of<IParameterTagCollection::IParameterTag, PARAMETER_TAG>::value, "Parameter TAG must be derived from IParameterTag." );

#if DEBUG_CONSOLE_OUTPUT
			std::shared_ptr<typename PARAMETER_TAG::TParameter> tParam = std::make_shared<typename PARAMETER_TAG::TParameter>( PARAMETER_TAG(), Quantity );

			std::cout  << "ParameterContainer <-- "<< (* tParam) << std::endl;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely insert the parameter into the parameter collection */
				this->mParameterCollection[ PARAMETER_TAG::ID::value ] = tParam;

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

#else
			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely insert the parameter into the parameter collection */
				this->mParameterCollection[ PARAMETER_TAG::ID::value ] = std::make_shared<typename PARAMETER_TAG::TParameter>( PARAMETER_TAG(), Quantity );

				/* The lock guard expires here so the parameter collection gets unlocked */
			}
#endif
		}

		/**
		 * @brief Parameter is stored in container check
		 *
		 * @param[in] Identification	Constrained parameter identification generated from DesingRules DB in component scope
		 *
		 * @returns true	{Parameter found within the container}
		 * @returns false	{Parameter was not found within the container}
		 */
		template<typename PARAMETER_TAG>
		bool isAvailable( void ) const noexcept
		{
			/* Check whether PARAMETER_TAG is compatible with IParameterTag interface */
			static_assert( std::is_base_of<IParameterTagCollection::IParameterTag, PARAMETER_TAG>::value, "Parameter TAG must be derived from IParameterTag." );

			bool tParameterFound = false;

			/* Thread-safe parameter collection access block */
			{
				/* Lock parameter collection */
				std::lock_guard<std::mutex> lock( this->mParameterCollectionMutex );

				/* Safely find parameter in collection */
				/* Once the find() reaches the end of the container, the parameter is not in */
				tParameterFound = !( this->mParameterCollection.find( PARAMETER_TAG::ID::value ) == this->mParameterCollection.end() );

				/* The lock guard expires here so the parameter collection gets unlocked */
			}

			/* If the parameter was NOT found within this parameter container, try to find it in linked one if linked. */
			if( ( !tParameterFound ) && ( !( this->mLinkedContainer.expired() ) ) )
			{
				/* Get the shared pointer to the linked container and ask whether the requested parameter tag is available in here */
				tParameterFound = ( ( this->mLinkedContainer ).lock() )->isAvailable<PARAMETER_TAG>();
			}

			/* Return the result */
			return( tParameterFound );
		}

	private:
		/**
		 * @brief Default ParameterContainer constructor
		 *
		 * Generated by compiler
		 */
		ParameterContainer( void ) noexcept = default;

		/**
		 * @brief ParameterContainer copy constructor
		 *
		 * Generated by compiler
		 */
		ParameterContainer( const ParameterContainer & ) noexcept = default;

		/**
		 * @brief Gather parameter info
		 *
		 * Try to gather detailed parameter information to be used in exception message.
		 *
		 * It tries to connect to DesignRules database and searches for constrained parameter identified by 'Identification'.
		 * If something goes wrong, only parameter ID is reported only.
		 *
		 * @param[in] Identification	Constrained parameter identification generated from DesingRules DB in component scope
		 *
		 * @throws Nothing
		 */
		template<typename PARAMETER_TAG>
		std::string getParameterInfo( void ) const noexcept( false )
		{
			/* Check whether PARAMETER_TAG is compatible with IParameterTag interface */
			static_assert( std::is_base_of<IParameterTagCollection::IParameterTag, PARAMETER_TAG>::value, "Parameter TAG must be derived from IParameterTag." );

			std::stringstream Stream;

			/* Parameter not found in the container. Try to find it in DesignRules to get the info */
			try
			{
				if( DesignRulesDBConnector::get_mutable_instance().isConnected() )
				{
					/* Setup the SQL query to read out the names of all the supported design rule options */
					SQLite::Statement Query( DesignRulesDBConnector::get_mutable_instance(), "SELECT Component,Identification,Name FROM Parameters WHERE ID = :ConstrainedParameterID LIMIT 1" );

					/* Bind requested parameter identification */
					Query.bind(":ConstrainedParameterID", PARAMETER_TAG::ID::value );

					/* Execute the query */
					while( Query.executeStep() )
					{
						Stream << Query.getColumn( "Component" ).getText() << "::";
						Stream << Query.getColumn( "Identification" ).getText();
						Stream << " (" << Query.getColumn( "Name" ).getText() << ")";
					}
				}
				else
				{
					/* DesignRules database is not connected. */
					BOOST_THROW_EXCEPTION( DesignRulesDBConnector::Exception::DesignRulesDBNotConnected() << Core::Exception::Message( "DesignRules DB is not connected." ) );
				}
			}
			/* Catch DesignRules DB not connected case */
			catch( const DesignRulesDBConnector::Exception::DesignRulesDBNotConnected & Exception )
			{
				/* Print out Identification... */
				Stream << PARAMETER_TAG::ID::value << " ";

				/* ...and what went wrong while getting more detailed info */
				Stream << "(Failed to get more detailed info because " << Exception.what() << ")";
			}
			catch( const SQLite::Exception & Exception )
			{
				/* Print out Identification... */
				Stream << PARAMETER_TAG::ID::value << " ";

				/* ...and what went wrong while getting more detailed info */
				Stream << "(Failed to get more detailed info because " << Exception.what() << ")";
			}

			return( Stream.str() );
		}

		/* Linked parameter container smart pointer. The pointer is weak as this parameter container does not own
		 * the linked one so the relation is classified weak */
		std::weak_ptr<ParameterContainer> mLinkedContainer;

		/* Parameter storage */
		TParameterCollection	mParameterCollection;

		/* The mutex must be made 'mutable' in order to allow it's modification in 'const' functions */
		mutable std::mutex		mParameterCollectionMutex;
	};
}

#undef DEBUG_CONSOLE_OUTPUT

#endif /* SOURCE_CORE_PARAMETER_PARAMETER_CONTAINER_H_ */
